# =============================================================================
# LLVM + MLIR Multi-Platform Release Builder
# =============================================================================
#
# Production-grade CI/CD pipeline for building and releasing LLVM and MLIR
# C API binaries. Designed for resilience: partial failures do not block
# the entire release process.
#
# Supported Platforms:
#   - Linux x86_64     (Ubuntu 22.04)
#   - macOS ARM64      (macOS 15 Apple Silicon)
#
# Key Features:
#   - Graceful degradation: releases proceed with available artifacts
#   - Comprehensive error handling and validation
#   - Concurrency control to prevent duplicate runs
#   - Timeouts to prevent hung builds from blocking resources
#   - Retry logic for network operations
#
# Assumptions (from build.sh):
#   - Creates llvm-mlir-${VERSION}-${platform} directories
#   - Produces lib/libLLVM.* and lib/libMLIR-C.* shared libraries
#
# Usage:
#   1. Manual: Actions > Run workflow
#   2. Automatic: Push a version tag (e.g., v21.1.8)
#
# =============================================================================

name: LLVM+MLIR Release

on:
  workflow_dispatch:
    inputs:
      llvm_version:
        description: 'LLVM version to build (e.g., 21, 22)'
        required: true
        default: '21'
      llvm_branch:
        description: 'LLVM branch/tag (e.g., release/21.x, release/22.x)'
        required: true
        default: 'release/21.x'
      release_tag:
        description: 'Release tag (e.g., v21.1.8)'
        required: true

  push:
    tags:
      - 'v*'

# =============================================================================
# PERMISSIONS
# Minimal permissions required for this workflow.
# =============================================================================
permissions:
  contents: write
  actions: read

# =============================================================================
# CONCURRENCY CONTROL
# Event-aware: uses input tag for dispatch, ref_name for tag push.
# =============================================================================
concurrency:
  group: release-${{ github.event_name == 'workflow_dispatch' && github.event.inputs.release_tag || github.ref_name }}
  cancel-in-progress: false

# =============================================================================
# ENVIRONMENT DEFAULTS
# =============================================================================
env:
  DEFAULT_JOBS: 4
  ARTIFACT_RETENTION_DAYS: 7
  # Computed version: use input for dispatch, extract from tag for push
  LLVM_VERSION: ${{ github.event.inputs.llvm_version || '21' }}
  LLVM_BRANCH: ${{ github.event.inputs.llvm_branch || 'release/21.x' }}
  RELEASE_TAG: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.release_tag || github.ref_name }}

# =============================================================================
# BUILD JOBS
# =============================================================================
jobs:

  # ---------------------------------------------------------------------------
  # Linux x86_64 Build
  # ---------------------------------------------------------------------------
  build-linux-x64:
    name: Linux x86_64
    runs-on: ubuntu-22.04
    timeout-minutes: 180
    continue-on-error: true

    outputs:
      result: ${{ steps.set-result.outputs.status }}
      artifact_name: ${{ steps.package.outputs.artifact_name }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Clean workspace
        run: |
          set -euo pipefail
          echo "Cleaning any stale build directories..."
          rm -rf llvm-project llvm-mlir-* build-llvm-* 2>/dev/null || true

      - name: Validate environment
        run: |
          set -euo pipefail
          echo "=== Environment Validation ==="
          echo "Runner OS: ${RUNNER_OS}"
          echo "Runner Arch: ${RUNNER_ARCH}"
          echo "Workspace: ${GITHUB_WORKSPACE}"
          echo "LLVM Version: ${{ env.LLVM_VERSION }}"
          echo "LLVM Branch: ${{ env.LLVM_BRANCH }}"
          echo "Available disk space:"
          df -h .
          echo ""

      - name: Install build dependencies
        run: |
          set -euo pipefail
          echo "Installing required packages..."
          sudo apt-get update
          sudo apt-get install -y cmake ninja-build python3 zlib1g-dev g++ file
          
          # Verify installations
          cmake --version || { echo "::error::cmake not found"; exit 1; }
          ninja --version || { echo "::error::ninja not found"; exit 1; }
          g++ --version || { echo "::error::g++ not found"; exit 1; }
          echo "Dependencies installed successfully"

      - name: Clone LLVM source
        id: clone
        run: |
          set -euo pipefail
          BRANCH="${{ env.LLVM_BRANCH }}"
          echo "Cloning LLVM from branch: ${BRANCH}"
          
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [[ ${RETRY_COUNT} -lt ${MAX_RETRIES} ]]; do
            if git clone --depth=1 --branch="${BRANCH}" https://github.com/llvm/llvm-project.git; then
              echo "LLVM source cloned successfully"
              break
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [[ ${RETRY_COUNT} -lt ${MAX_RETRIES} ]]; then
              echo "::warning::Clone failed, retrying (${RETRY_COUNT}/${MAX_RETRIES})..."
              sleep 10
              rm -rf llvm-project 2>/dev/null || true
            else
              echo "::error::Failed to clone LLVM repository after ${MAX_RETRIES} attempts"
              exit 1
            fi
          done

      - name: Build LLVM and MLIR
        id: build
        run: |
          set -euo pipefail
          
          if [[ ! -f "build.sh" ]]; then
            echo "::error::build.sh not found in repository root"
            exit 1
          fi
          
          chmod +x build.sh
          echo "Starting build with ${{ env.DEFAULT_JOBS }} parallel jobs..."
          
          if ! ./build.sh; then
            echo "::error::LLVM build failed"
            exit 1
          fi
          echo "Build completed successfully"
        env:
          LLVM_VERSION: ${{ env.LLVM_VERSION }}
          JOBS: 4

      - name: Verify build output
        id: verify
        run: |
          set -euo pipefail
          
          VERSION="${{ env.LLVM_VERSION }}"
          EXPECTED_DIR="llvm-mlir-${VERSION}-linux-x64"
          
          echo "Looking for build output: ${EXPECTED_DIR}"
          
          if [[ ! -d "${EXPECTED_DIR}" ]]; then
            INSTALL_DIR=$(ls -d llvm-mlir-*-linux-x64 2>/dev/null | head -1 || true)
            if [[ -z "${INSTALL_DIR}" ]]; then
              echo "::error::Build output directory not found"
              ls -la
              exit 1
            fi
            echo "::warning::Using fallback directory: ${INSTALL_DIR}"
          else
            INSTALL_DIR="${EXPECTED_DIR}"
          fi
          
          echo "install_dir=${INSTALL_DIR}" >> $GITHUB_OUTPUT
          echo "Verifying build outputs in: ${INSTALL_DIR}"
          
          if [[ ! -d "${INSTALL_DIR}/lib" ]]; then
            echo "::error::lib directory not found in ${INSTALL_DIR}"
            exit 1
          fi
          
          # Find ELF shared object for LLVM (avoid linker scripts)
          echo "Checking LLVM C API..."
          LLVM_LIB=""
          for f in "${INSTALL_DIR}"/lib/libLLVM*.so*; do
            if [[ -f "$f" ]] && file "$f" | grep -q "ELF"; then
              LLVM_LIB="$f"
              break
            fi
          done
          
          if [[ -z "${LLVM_LIB}" ]]; then
            echo "::error::No ELF libLLVM shared object found"
            ls -la "${INSTALL_DIR}/lib/"
            exit 1
          fi
          
          if ! nm -D "${LLVM_LIB}" 2>/dev/null | grep -q "LLVMContextCreate"; then
            echo "::error::LLVM C API symbols not found in ${LLVM_LIB}"
            exit 1
          fi
          echo "LLVM C API verified: ${LLVM_LIB}"
          
          # Find ELF shared object for MLIR C API
          echo "Checking MLIR C API..."
          MLIR_LIB=""
          for f in "${INSTALL_DIR}"/lib/libMLIR-C*.so*; do
            if [[ -f "$f" ]] && file "$f" | grep -q "ELF"; then
              MLIR_LIB="$f"
              break
            fi
          done
          
          if [[ -z "${MLIR_LIB}" ]]; then
            echo "::error::No ELF libMLIR-C shared object found"
            ls -la "${INSTALL_DIR}/lib/"
            exit 1
          fi
          
          if ! nm -D "${MLIR_LIB}" 2>/dev/null | grep -q "mlirContextCreate"; then
            echo "::error::MLIR C API symbols not found in ${MLIR_LIB}"
            exit 1
          fi
          echo "MLIR C API verified: ${MLIR_LIB}"

      - name: Create distribution packages
        id: package
        run: |
          set -euo pipefail
          
          INSTALL_DIR="${{ steps.verify.outputs.install_dir }}"
          VERSION="${{ env.LLVM_VERSION }}"
          
          echo "Creating distribution packages from: ${INSTALL_DIR}"
          
          MINIMAL_DIR="${INSTALL_DIR}-minimal"
          MINIMAL_PKG="${MINIMAL_DIR}.tar.gz"
          FULL_PKG="${INSTALL_DIR}-full.tar.gz"
          
          # Minimal package
          echo "Building minimal package..."
          mkdir -p "${MINIMAL_DIR}/lib"
          
          # Copy only ELF shared libraries
          for f in "${INSTALL_DIR}"/lib/*.so*; do
            if [[ -f "$f" ]] && file "$f" | grep -q "ELF"; then
              cp "$f" "${MINIMAL_DIR}/lib/"
            fi
          done
          
          echo "LLVM ${VERSION}" > "${MINIMAL_DIR}/lib/version.txt"
          
          MINIMAL_SIZE=$(du -sb "${MINIMAL_DIR}" | cut -f1)
          if [[ "${MINIMAL_SIZE}" -lt 1000000 ]]; then
            echo "::error::Minimal package suspiciously small (${MINIMAL_SIZE} bytes)"
            exit 1
          fi
          echo "Minimal package size: ${MINIMAL_SIZE} bytes"
          
          tar -czf "${MINIMAL_PKG}" "${MINIMAL_DIR}"
          sha256sum "${MINIMAL_PKG}" > "${MINIMAL_PKG}.sha256"
          
          # Full package
          echo "Building full package..."
          tar -czf "${FULL_PKG}" "${INSTALL_DIR}"
          sha256sum "${FULL_PKG}" > "${FULL_PKG}.sha256"
          
          echo "Packages created:"
          ls -lh *.tar.gz
          
          echo "artifact_name=${INSTALL_DIR}" >> $GITHUB_OUTPUT

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: linux-x64
          path: |
            llvm-mlir-*-linux-x64-minimal.tar.gz
            llvm-mlir-*-linux-x64-minimal.tar.gz.sha256
            llvm-mlir-*-linux-x64-full.tar.gz
            llvm-mlir-*-linux-x64-full.tar.gz.sha256
          retention-days: ${{ env.ARTIFACT_RETENTION_DAYS }}
          if-no-files-found: error

      - name: Set job result
        id: set-result
        if: always()
        run: |
          set -euo pipefail
          STATUS=success
          
          # Check critical step outcomes
          if [[ "${{ steps.build.outcome }}" != "success" ]]; then
            STATUS=failure
            echo "Build step failed"
          fi
          
          if [[ "${{ steps.verify.outcome }}" != "success" ]]; then
            STATUS=failure
            echo "Verify step failed"
          fi
          
          if [[ "${{ steps.package.outcome }}" != "success" ]]; then
            STATUS=failure
            echo "Package step failed"
          fi
          
          echo "Final status: ${STATUS}"
          echo "status=${STATUS}" >> $GITHUB_OUTPUT

  # ---------------------------------------------------------------------------
  # macOS ARM64 (Apple Silicon) Build
  # ---------------------------------------------------------------------------
  build-macos-arm64:
    name: macOS Apple Silicon (ARM64)
    runs-on: macos-15
    timeout-minutes: 180
    continue-on-error: true

    outputs:
      result: ${{ steps.set-result.outputs.status }}
      artifact_name: ${{ steps.package.outputs.artifact_name }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Clean workspace
        run: |
          set -euo pipefail
          echo "Cleaning any stale build directories..."
          rm -rf llvm-project llvm-mlir-* build-llvm-* 2>/dev/null || true

      - name: Validate environment
        run: |
          set -euo pipefail
          echo "=== Environment Validation ==="
          echo "Runner OS: ${RUNNER_OS}"
          echo "Runner Arch: ${RUNNER_ARCH}"
          echo "Workspace: ${GITHUB_WORKSPACE}"
          echo "LLVM Version: ${{ env.LLVM_VERSION }}"
          echo "LLVM Branch: ${{ env.LLVM_BRANCH }}"
          echo "Available disk space:"
          df -h .
          echo ""

      - name: Install build dependencies
        run: |
          set -euo pipefail
          echo "Installing Homebrew packages..."
          
          brew list cmake &>/dev/null || brew install cmake
          brew list ninja &>/dev/null || brew install ninja
          
          cmake --version || { echo "::error::cmake not found"; exit 1; }
          ninja --version || { echo "::error::ninja not found"; exit 1; }
          echo "Dependencies installed"

      - name: Clone LLVM source
        id: clone
        run: |
          set -euo pipefail
          BRANCH="${{ env.LLVM_BRANCH }}"
          echo "Cloning LLVM from branch: ${BRANCH}"
          
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          while [[ ${RETRY_COUNT} -lt ${MAX_RETRIES} ]]; do
            if git clone --depth=1 --branch="${BRANCH}" https://github.com/llvm/llvm-project.git; then
              echo "LLVM source cloned successfully"
              break
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [[ ${RETRY_COUNT} -lt ${MAX_RETRIES} ]]; then
              echo "::warning::Clone failed, retrying (${RETRY_COUNT}/${MAX_RETRIES})..."
              sleep 10
              rm -rf llvm-project 2>/dev/null || true
            else
              echo "::error::Failed to clone LLVM repository after ${MAX_RETRIES} attempts"
              exit 1
            fi
          done

      - name: Build LLVM and MLIR
        id: build
        run: |
          set -euo pipefail
          
          if [[ ! -f "build.sh" ]]; then
            echo "::error::build.sh not found in repository root"
            exit 1
          fi
          
          chmod +x build.sh
          echo "Starting build with ${{ env.DEFAULT_JOBS }} parallel jobs..."
          
          if ! ./build.sh; then
            echo "::error::LLVM build failed"
            exit 1
          fi
          echo "Build completed successfully"
        env:
          LLVM_VERSION: ${{ env.LLVM_VERSION }}
          JOBS: 4

      - name: Verify build output
        id: verify
        run: |
          set -euo pipefail
          
          VERSION="${{ env.LLVM_VERSION }}"
          EXPECTED_DIR="llvm-mlir-${VERSION}-macos-arm64"
          
          echo "Looking for build output: ${EXPECTED_DIR}"
          
          if [[ ! -d "${EXPECTED_DIR}" ]]; then
            INSTALL_DIR=$(ls -d llvm-mlir-*-macos-arm64 2>/dev/null | head -1 || true)
            if [[ -z "${INSTALL_DIR}" ]]; then
              echo "::error::Build output directory not found"
              ls -la
              exit 1
            fi
            echo "::warning::Using fallback directory: ${INSTALL_DIR}"
          else
            INSTALL_DIR="${EXPECTED_DIR}"
          fi
          
          echo "install_dir=${INSTALL_DIR}" >> $GITHUB_OUTPUT
          echo "Verifying build outputs in: ${INSTALL_DIR}"
          
          if [[ ! -d "${INSTALL_DIR}/lib" ]]; then
            echo "::error::lib directory not found in ${INSTALL_DIR}"
            exit 1
          fi
          
          # Check LLVM C API (macOS uses Mach-O)
          echo "Checking LLVM C API..."
          LLVM_LIB=""
          for f in "${INSTALL_DIR}"/lib/libLLVM*.dylib; do
            if [[ -f "$f" ]] && file "$f" | grep -q "Mach-O"; then
              LLVM_LIB="$f"
              break
            fi
          done
          
          if [[ -z "${LLVM_LIB}" ]]; then
            echo "::error::No Mach-O libLLVM dylib found"
            ls -la "${INSTALL_DIR}/lib/"
            exit 1
          fi
          
          if ! nm "${LLVM_LIB}" 2>/dev/null | grep -q "LLVMContextCreate"; then
            echo "::error::LLVM C API symbols not found in ${LLVM_LIB}"
            exit 1
          fi
          echo "LLVM C API verified: ${LLVM_LIB}"
          
          # Check MLIR C API
          echo "Checking MLIR C API..."
          MLIR_LIB=""
          for f in "${INSTALL_DIR}"/lib/libMLIR-C*.dylib; do
            if [[ -f "$f" ]] && file "$f" | grep -q "Mach-O"; then
              MLIR_LIB="$f"
              break
            fi
          done
          
          if [[ -z "${MLIR_LIB}" ]]; then
            echo "::error::No Mach-O libMLIR-C dylib found"
            ls -la "${INSTALL_DIR}/lib/"
            exit 1
          fi
          
          if ! nm "${MLIR_LIB}" 2>/dev/null | grep -q "mlirContextCreate"; then
            echo "::error::MLIR C API symbols not found in ${MLIR_LIB}"
            exit 1
          fi
          echo "MLIR C API verified: ${MLIR_LIB}"

      - name: Create distribution packages
        id: package
        run: |
          set -euo pipefail
          
          INSTALL_DIR="${{ steps.verify.outputs.install_dir }}"
          VERSION="${{ env.LLVM_VERSION }}"
          
          echo "Creating distribution packages from: ${INSTALL_DIR}"
          
          MINIMAL_DIR="${INSTALL_DIR}-minimal"
          MINIMAL_PKG="${MINIMAL_DIR}.tar.gz"
          FULL_PKG="${INSTALL_DIR}-full.tar.gz"
          
          # Minimal package
          echo "Building minimal package..."
          mkdir -p "${MINIMAL_DIR}/lib"
          
          # Copy Mach-O shared libraries
          for f in "${INSTALL_DIR}"/lib/*.dylib; do
            if [[ -f "$f" ]] && file "$f" | grep -q "Mach-O"; then
              cp "$f" "${MINIMAL_DIR}/lib/"
            fi
          done
          
          echo "LLVM ${VERSION}" > "${MINIMAL_DIR}/lib/version.txt"
          
          MINIMAL_SIZE=$(du -sk "${MINIMAL_DIR}" | cut -f1)
          MINIMAL_SIZE_BYTES=$((MINIMAL_SIZE * 1024))
          if [[ "${MINIMAL_SIZE_BYTES}" -lt 1000000 ]]; then
            echo "::error::Minimal package suspiciously small (${MINIMAL_SIZE_BYTES} bytes)"
            exit 1
          fi
          echo "Minimal package size: ${MINIMAL_SIZE_BYTES} bytes"
          
          tar -czf "${MINIMAL_PKG}" "${MINIMAL_DIR}"
          shasum -a 256 "${MINIMAL_PKG}" > "${MINIMAL_PKG}.sha256"
          
          # Full package
          echo "Building full package..."
          tar -czf "${FULL_PKG}" "${INSTALL_DIR}"
          shasum -a 256 "${FULL_PKG}" > "${FULL_PKG}.sha256"
          
          echo "Packages created:"
          ls -lh *.tar.gz
          
          echo "artifact_name=${INSTALL_DIR}" >> $GITHUB_OUTPUT

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: macos-arm64
          path: |
            llvm-mlir-*-macos-arm64-minimal.tar.gz
            llvm-mlir-*-macos-arm64-minimal.tar.gz.sha256
            llvm-mlir-*-macos-arm64-full.tar.gz
            llvm-mlir-*-macos-arm64-full.tar.gz.sha256
          retention-days: ${{ env.ARTIFACT_RETENTION_DAYS }}
          if-no-files-found: error

      - name: Set job result
        id: set-result
        if: always()
        run: |
          set -euo pipefail
          STATUS=success
          
          # Check critical step outcomes
          if [[ "${{ steps.build.outcome }}" != "success" ]]; then
            STATUS=failure
            echo "Build step failed"
          fi
          
          if [[ "${{ steps.verify.outcome }}" != "success" ]]; then
            STATUS=failure
            echo "Verify step failed"
          fi
          
          if [[ "${{ steps.package.outcome }}" != "success" ]]; then
            STATUS=failure
            echo "Package step failed"
          fi
          
          echo "Final status: ${STATUS}"
          echo "status=${STATUS}" >> $GITHUB_OUTPUT

  # ---------------------------------------------------------------------------
  # Create GitHub Release
  # Aggregates available artifacts and publishes a versioned release.
  # Proceeds with partial artifacts if some builds failed.
  # ---------------------------------------------------------------------------
  create-release:
    name: Create Release
    needs: [build-linux-x64, build-macos-arm64]
    runs-on: ubuntu-latest
    timeout-minutes: 15
    if: always()

    steps:
      - name: Evaluate build results
        id: evaluate
        run: |
          set -euo pipefail
          
          LINUX_RESULT="${{ needs.build-linux-x64.outputs.result }}"
          MACOS_RESULT="${{ needs.build-macos-arm64.outputs.result }}"
          
          # Fallback to job result if output is empty
          [[ -z "${LINUX_RESULT}" ]] && LINUX_RESULT="${{ needs.build-linux-x64.result }}"
          [[ -z "${MACOS_RESULT}" ]] && MACOS_RESULT="${{ needs.build-macos-arm64.result }}"
          
          echo "=== Build Results ==="
          echo "Linux x86_64:         ${LINUX_RESULT}"
          echo "macOS Apple Silicon:  ${MACOS_RESULT}"
          echo ""
          
          SUCCESS_COUNT=0
          [[ "${LINUX_RESULT}" == "success" ]] && ((SUCCESS_COUNT++)) || true
          [[ "${MACOS_RESULT}" == "success" ]] && ((SUCCESS_COUNT++)) || true
          
          echo "Successful builds: ${SUCCESS_COUNT}/2"
          
          if [[ ${SUCCESS_COUNT} -eq 0 ]]; then
            echo "::error::All builds failed. Cannot create release."
            echo "should_release=false" >> $GITHUB_OUTPUT
            echo "success_count=0" >> $GITHUB_OUTPUT
            # Exit 0 for graceful degradation - workflow stays green
            exit 0
          fi
          
          echo "should_release=true" >> $GITHUB_OUTPUT
          echo "success_count=${SUCCESS_COUNT}" >> $GITHUB_OUTPUT
          echo "linux_result=${LINUX_RESULT}" >> $GITHUB_OUTPUT
          echo "macos_result=${MACOS_RESULT}" >> $GITHUB_OUTPUT
          
          if [[ ${SUCCESS_COUNT} -lt 2 ]]; then
            echo "::warning::Creating partial release. Some platforms failed."
          fi

      - name: Download available artifacts
        if: steps.evaluate.outputs.should_release == 'true'
        uses: actions/download-artifact@v4
        with:
          path: artifacts
        continue-on-error: true

      - name: Prepare release assets
        if: steps.evaluate.outputs.should_release == 'true'
        id: prepare
        run: |
          set -euo pipefail
          
          echo "Collecting release assets..."
          mkdir -p release-assets
          
          find artifacts -name "*.tar.gz" -exec cp {} release-assets/ \; 2>/dev/null || true
          find artifacts -name "*.sha256" -exec cp {} release-assets/ \; 2>/dev/null || true
          
          PACKAGE_COUNT=$(find release-assets -name "*.tar.gz" 2>/dev/null | wc -l || echo 0)
          echo "Found ${PACKAGE_COUNT} packages"
          
          if [[ "${PACKAGE_COUNT}" -eq 0 ]]; then
            echo "::error::No packages found for release"
            exit 1
          fi
          
          echo "Release assets:"
          ls -lh release-assets/
          
          # Determine actual filenames for release body
          LINUX_MINIMAL=$(ls release-assets/*linux-x64-minimal.tar.gz 2>/dev/null | xargs -n1 basename || echo "Not available")
          LINUX_FULL=$(ls release-assets/*linux-x64-full.tar.gz 2>/dev/null | xargs -n1 basename || echo "Not available")
          MACOS_MINIMAL=$(ls release-assets/*macos-arm64-minimal.tar.gz 2>/dev/null | xargs -n1 basename || echo "Not available")
          MACOS_FULL=$(ls release-assets/*macos-arm64-full.tar.gz 2>/dev/null | xargs -n1 basename || echo "Not available")
          
          LINUX_STATUS="Not available"
          MACOS_STATUS="Not available"
          
          [[ "${{ steps.evaluate.outputs.linux_result }}" == "success" ]] && LINUX_STATUS="Available"
          [[ "${{ steps.evaluate.outputs.macos_result }}" == "success" ]] && MACOS_STATUS="Available"
          
          echo "linux_status=${LINUX_STATUS}" >> $GITHUB_OUTPUT
          echo "macos_status=${MACOS_STATUS}" >> $GITHUB_OUTPUT
          echo "linux_minimal=${LINUX_MINIMAL}" >> $GITHUB_OUTPUT
          echo "linux_full=${LINUX_FULL}" >> $GITHUB_OUTPUT
          echo "macos_minimal=${MACOS_MINIMAL}" >> $GITHUB_OUTPUT
          echo "macos_full=${MACOS_FULL}" >> $GITHUB_OUTPUT

      - name: Publish GitHub release
        if: steps.evaluate.outputs.should_release == 'true'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.RELEASE_TAG }}
          name: LLVM ${{ env.LLVM_VERSION }} + MLIR C API
          body: |
            # LLVM ${{ env.LLVM_VERSION }} + MLIR C API
            
            Production-ready LLVM and MLIR libraries with full C API support for FFI usage.
            
            ---
            
            ## Package Availability
            
            | Platform | Status | Minimal | Full |
            |----------|--------|---------|------|
            | Linux x86_64 | ${{ steps.prepare.outputs.linux_status }} | `${{ steps.prepare.outputs.linux_minimal }}` | `${{ steps.prepare.outputs.linux_full }}` |
            | macOS Apple Silicon | ${{ steps.prepare.outputs.macos_status }} | `${{ steps.prepare.outputs.macos_minimal }}` | `${{ steps.prepare.outputs.macos_full }}` |
            
            **Package Sizes:** Minimal (~50-80 MB) for runtime FFI | Full (~180-220 MB) for development
            
            ---
            
            ## Quick Start
            
            ```bash
            # Extract
            tar -xzf llvm-mlir-*-minimal.tar.gz
            
            # Verify (Linux)
            nm -D llvm-mlir-*/lib/libLLVM.so* | grep LLVMContextCreate
            
            # Verify (macOS)
            nm llvm-mlir-*/lib/libLLVM.dylib | grep LLVMContextCreate
            ```
            
            ---
            
            ## Build Details
            
            | Property | Value |
            |----------|-------|
            | LLVM Branch | `${{ env.LLVM_BRANCH }}` |
            | Targets | X86, AArch64, RISCV, NVPTX, AMDGPU, SPIRV |
            | Execution Engine | Enabled |
            | PDL | Enabled |
            | IRDL | Enabled |
            | Transform Dialect | Enabled |
            
            ---
            
            ## Integrity Check
            
            ```bash
            # Linux
            sha256sum -c <package>.tar.gz.sha256
            
            # macOS
            shasum -a 256 -c <package>.tar.gz.sha256
            ```
            
          files: release-assets/*
          draft: false
          prerelease: false
          fail_on_unmatched_files: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Summary
        if: always()
        run: |
          echo "## Release Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Platform | Result |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Linux x86_64 | ${{ steps.evaluate.outputs.linux_result || needs.build-linux-x64.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| macOS ARM64 | ${{ steps.evaluate.outputs.macos_result || needs.build-macos-arm64.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ steps.evaluate.outputs.should_release }}" == "true" ]]; then
            echo "Release created with ${{ steps.evaluate.outputs.success_count }}/2 platforms." >> $GITHUB_STEP_SUMMARY
          else
            echo "Release was not created due to build failures." >> $GITHUB_STEP_SUMMARY
          fi
